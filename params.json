{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","body":"# Recommendable\r\n\r\nRecommendable is a gem that allows you to quickly add a recommendation engine for Likes and Dislikes to your Ruby application using my version of [Jaccardian similarity and memory-based collaborative filtering][collaborative filtering].\r\n\r\n## Requirements\r\n\r\n* Ruby 1.8.7 or 1.9.x\r\n* ActiveRecord, DataMapper, Mongoid, or MongoMapper\r\n* Sidekiq, Resque, DelayedJob (optional but highly recommended)\r\n\r\nBundling one of the queueing systems above is highly recommended to avoid having to manually refresh users' recommendations. If running on Rails 4, the built-in queueing system is supported. If you bundle [Sidekiq][sidekiq], [Resque][resque], or [DelayedJob][delayed_job], Recommendable will use your bundled queueing system instead. If bundling Sidekiq, you should also include ['sidekiq-middleware'][sidekiq-middleware] in your Gemfile to ensure that a user will not get enqueued more than once at a time. If bundling Resque, you should include ['resque-loner'][resque-loner] for this. As far as I know, there is no current way to avoid duplicate jobs in DelayedJob.\r\n\r\n## Installation\r\n\r\nAdd the following to your application's `Gemfile`:\r\n\r\n``` ruby\r\n  gem 'recommendable'\r\n```\r\n\r\nAfter bundling, you should configure Recommendable. Do this somewhere after you've required it, but before it's actually used. For example, Rails users would create an initializer (`config/initializers/recommendable.rb`):\r\n\r\n``` ruby\r\nrequire 'redis'\r\n\r\nRecommendable.configure do |config|\r\n  # Recommendable's connection to Redis\r\n  config.redis = Redis.new(:host => 'localhost', :port => 6379, :db => 0)\r\n\r\n  # A prefix for all keys Recommendable uses\r\n  config.redis_namespace = :recommendable\r\n\r\n  # Whether or not to automatically enqueue users to have their recommendations\r\n  # refreshed after they like/dislike an item\r\n  config.auto_enqueue = true\r\n\r\n  # The name of the queue that background jobs will be placed in\r\n  config.queue_name = :recommendable\r\n\r\n  # The number of nearest neighbors (k-NN) to check when updating\r\n  # recommendations for a user. Set to `nil` if you want to check all\r\n  # other users as opposed to a subset of the nearest ones.\r\n  config.nearest_neighbors = nil\r\nend\r\n```\r\n\r\nThe values listed above are the defaults. I recommend playing around with the `nearest_neighbors` setting. A higher value will provide more accurate recommendations at the cost of more time spent generating them. Find your balance.\r\n\r\n## Usage\r\n\r\nIn your ONE model that will be receiving recommendations:\r\n\r\n``` ruby\r\nclass User\r\n  recommends :movies, :books, :minerals, :other_things\r\n\r\n  # ...\r\nend\r\n```\r\n\r\n### Liking\r\n\r\nYour users should now be able to `like` your recommendable objects:\r\n\r\n``` ruby\r\n>> user.like(movie)\r\n=> true\r\n>> user.likes?(movie)\r\n=> true\r\n>> user.rated?(movie)\r\n=> true # also true if user.dislikes?(movie)\r\n>> user.liked_movies\r\n=> [#<Movie id: 23, name: \"2001: A Space Odyssey\">]\r\n>> user.liked_movie_ids\r\n=> [\"23\"]\r\n>> user.like(book)\r\n=> true\r\n>> user.likes\r\n=> [#<Movie id: 23, name: \"2001: A Space Odyssey\">, #<Book id: 42, title: \"100 Years of Solitude\">]\r\n>> user.likes_count\r\n=> 2\r\n>> user.liked_movies_count\r\n=> 1\r\n>> user.likes_in_common_with(friend)\r\n=> [#<Movie id: 23, name: \"2001: A Space Odyssey\">, #<Book id: 42, title: \"100 Years of Solitude\">]\r\n>> user.liked_movies_in_common_with(friend)\r\n=> [#<Movie id: 23, name: \"2001: A Space Odyssey\">]\r\n>> movie.liked_by_count\r\n=> 2\r\n>> movie.liked_by\r\n=> [#<User username: 'davidbowman'>, #<User username: 'frankpoole'>]\r\n```\r\n\r\n### Disliking\r\n\r\nIdentical to Liking. Just replace the verb.\r\n\r\n``` ruby\r\n>> user.dislike(movie)\r\n>> user.dislikes?(movie)\r\n>> user.disliked_movies\r\n>> user.disliked_movie_ids\r\n>> user.dislikes\r\n>> user.dislikes_count\r\n>> user.disliked_movies_count\r\n>> user.dislikes_in_common_with(friend)\r\n>> user.disliked_movies_in_common_with(friend)\r\n>> movie.disliked_by_count\r\n>> movie.disliked_by\r\n```\r\n\r\n### Bookmarking\r\n\r\nThis is a system for users to keep track of items in a \"save for later\" kind of way. Users can bookmark any item that they have not hidden, including items they've liked or disliked. Bookmarked items will be removed from a user's recommendations.\r\n\r\n``` ruby\r\n>> user.bookmark(movie)\r\n>> user.bookmarks?(movie)\r\n>> user.rated?(movie) # false unless user liked/disliked movie\r\n>> user.bookmarked_movies\r\n>> user.bookmarked_movie_ids\r\n>> user.bookmarks\r\n>> user.bookmarks_count\r\n>> user.bookmarked_movies_count\r\n>> user.bookmarks_in_common_with(friend\r\n>> user.bookmarked_movies_in_common_with(friend)\r\n```\r\n\r\n### Hiding\r\n\r\nAside from abstaining to rate, this is the closest Recommendable will _ever_ get to a \"neutral\" voting option. Hiding items provides you with a way to let users tell you what they couldn't care less about.\r\n\r\n``` ruby\r\n>> user.hide(movie)\r\n>> user.hides?(movie)\r\n>> user.rated?(movie) # false\r\n>> user.hidden_movies\r\n>> user.hidden_movie_ids\r\n>> user.hiding\r\n>> user.hidden_count\r\n>> user.hidden_movies_count\r\n>> user.hiding_in_common_with(friend)\r\n>> user.hidden_movies_in_common_with(friend)\r\n```\r\n\r\nUse this as you will, but hidden items can not be liked, disliked, or bookmarked. They are removed from recommendations and completely ignored by Recommendable unless removed from a user's set of hidden items. Speaking of which...\r\n\r\n### Removing from sets\r\n\r\nEach of the actions above has an opposite \"un\" action to remove items from a list:\r\n\r\n``` ruby\r\n>> user.unlike(movie)\r\n=> true\r\n>> user.undislike(book)\r\n=> true\r\n>> user.unbookmark(mineral)\r\n=> true\r\n>> user.unhide(other_thing)\r\n=> true\r\n```\r\n\r\n### Recommendations\r\n\r\nAnd here we are. Assuming your queues are being processed, users should begin receiving recommendations as soon as they have rated items that other users have also rated.\r\n\r\n``` ruby\r\n>> friend.like(Movie.where(:name => \"2001: A Space Odyssey\").first)\r\n>> friend.like(Book.where(:title => \"A Clockwork Orange\").first)\r\n>> friend.like(Book.where(:title => \"Brave New World\").first)\r\n>> user.like(Book.where(:title => \"A Clockwork Orange\").first)\r\n# ...\r\n>> user.recommendations\r\n=> [#<Movie name: \"2001 A Space Odyssey\">, #<Book title: \"Brave New World\">]\r\n>> user.recommended_movies\r\n=> [#<Movie name: \"A Clockwork Orange\">]\r\n>> user.similar_raters\r\n=> [#<User username: \"frankpoole\">, #<User username: \"davidbowman\">]\r\n```\r\n\r\n### The \"best\" of your Recommendable models\r\n\r\nRecommendable does some maths in the background to calculate which of your Recommended objects, based on likes and dislikes, are the best of the best. This algorithm is similar to [the algorithm][best-algorithm] Reddit uses to sort the \"best\" comments. Using the `.top` query method on your Recommendable models will return the coolest stuff you have to offer sorted by awesomeness:\r\n\r\n``` ruby\r\n>> Movie.top\r\n=> #<Movie name: \"2001: A Space Odyssey\">\r\n>> Movie.top(3)\r\n=> [#<Movie name: \"2001: A Space Odyssey\">, #<Movie name: \"A Clockwork Orange\">, #<Movie name: \"The Shining\">]\r\n```\r\n\r\n### Callbacks\r\n\r\nRecommendable uses [apotonick/hooks][hooks] to implement before/after callbacks for liking, disliking, and more.\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  has_one :feed\r\n\r\n  recommends :movies\r\n  after_like :update_feed\r\n    \r\n  def update_feed(obj)\r\n    feed.update \"liked #{obj.name}\"\r\n  end\r\nend\r\n```\r\n    \r\nYou can define before/after hooks for `(un)like`, `(un)dislike`, `(un)bookmark`, and `(un)hide`. Each hook takes the recommendable object as an argument and can be a block or a method name.\r\n\r\n### A note on the dynamic finders\r\n\r\nAll of the dynamically defined finders return a Relation. This means that, assuming your ORM's queries are chainable, you can keep that chain going.\r\n\r\n```ruby\r\ncurrent_user.liked_movies.limit(10)\r\ncurrent_user.bookmarked_books.where(:author => \"Cormac McCarthy\")\r\ncurrent_user.disliked_movies.joins(:cast_members).where('cast_members.name = Kim Kardashian')\r\ncurrent_user.ignored_minerals.order('density DESC')\r\ncurrent_user.recommended_movies.where('year < 2010')\r\nbook.liked_by.order('age DESC').limit(20)\r\nmovie.disliked_by.where('age > 18')\r\n```\r\n\r\n## Installing Redis\r\n\r\nRecommendable requires Redis to deliver recommendations. The collaborative filtering logic is based almost entirely on set math, and Redis is blazing fast for this. _NOTE: Your redis database MUST be persistent._\r\n\r\n### Mac OS X\r\n\r\nFor Mac OS X users, homebrew is by far the easiest way to install Redis. Make sure to read the caveats after installation!\r\n\r\n``` bash\r\n$ brew install redis\r\n```\r\n\r\n### Linux\r\n\r\nFor Linux users, there is a package on apt-get.\r\n\r\n``` bash\r\n$ sudo apt-get install redis-server\r\n$ redis-server\r\n```\r\n\r\nRedis will now be running on localhost:6379. After a second, you can hit `ctrl-\\` to detach and keep Redis running in the background.\r\n\r\nWhy not stars?\r\n--------------\r\nI'll let Randall Munroe of [XKCD](http://xkcd.com/) take this one for me:\r\n\r\n[![I got lost and wandered into the world's creepiest cemetery, where the headstones just had names and star ratings. Freaked me out. When I got home I tried to leave the cemetery a bad review on Yelp, but as my hand hovered over the 'one star' button I felt this distant chill ...](http://imgs.xkcd.com/comics/star_ratings.png)](http://xkcd.com/1098/)\r\n\r\nContributing to recommendable\r\n-----------------------------\r\n \r\nOnce you've made your great commits:\r\n\r\n1. [Fork][forking] recommendable\r\n2. Create a feature branch\r\n3. Write your code (and tests please)\r\n4. Push to your branch's origin\r\n5. Create a [Pull Request][pull requests] from your branch\r\n6. That's it!\r\n\r\nLinks\r\n-----\r\n* Code: `git clone git://github.com/davidcelis/recommendable.git`\r\n* Home: <http://github.com/davidcelis/recommendable>\r\n* Docs: <http://rubydoc.info/gems/recommendable/frames>\r\n* Bugs: <http://github.com/davidcelis/recommendable/issues>\r\n* Gems: <http://rubygems.org/gems/recommendable>\r\n\r\nCopyright\r\n---------\r\n\r\nCopyright Â© 2012 David Celis. See LICENSE.txt for further details.\r\n\r\n[stars]: http://davidcelis.com/blog/2012/02/01/why-i-hate-five-star-ratings/\r\n[sidekiq]: https://github.com/mperham/sidekiq\r\n[sidekiq-middleware]: https://github.com/krasnoukhov/sidekiq-middleware\r\n[delayed_job]: https://github.com/tobi/delayed_job\r\n[resque]: https://github.com/defunkt/resque\r\n[resque-loner]: https://github.com/jayniz/resque-loner\r\n[hooks]: https://github.com/apotonick/hooks\r\n[forking]: http://help.github.com/forking/\r\n[pull requests]: http://help.github.com/pull-requests/\r\n[collaborative filtering]: http://davidcelis.com/blog/2012/02/07/collaborative-filtering-with-likes-and-dislikes/\r\n[recommendable]: http://davidcelis.github.com/recommendable/\r\n[documentation]: http://rubydoc.info/gems/recommendable/frames\r\n[best-algorithm]: http://www.evanmiller.org/how-not-to-sort-by-average-rating.html","tagline":"A recommendation engine for Likes and Dislikes in Rails 3","name":"Recommendable"}